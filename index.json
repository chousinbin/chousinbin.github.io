[{"content":"Hugo 生成的静态资源在 /public/* 下，为了方便部署，可以在 GitHub 创建两个仓库。\n一个名为 HugoBlog 存储 Hugo 整体资源，另一个名为 chousinbin.github.io 存储 /public/* 文件，发布网站。\n为了方便两个仓库的同步部署，可以使用 GitHub Actions 帮助自动部署。\n1. 创建 GitHub token GitHub - 头像 - Setting - Developer settings - Personal access tokens - Generate new token\n为 token 起一个名字，保质期设置为永久，勾选 workflow，生成 token。\n注意：生成之后要立即复制 token 到一个安全地方，因为之后你将无法再次从 GitHub 中获取。\n2. 为私有仓库创建 Actions Secrets 进入私有仓库 HugoBlog - 点击 Setting - Secrets and variables - Actions - New repository secret\n默认名为 MY_PAT，值为第一步生成的 token。\n3. 创建 Actions 在本地 HugoBlog 目录下创建 ./github/workflows/main.yaml 文件，复制以下内容到 main.yaml 中，并做出相应修改。\n1name: GitHub Pages 2 3on: 4 push: 5 branches: 6 - master # 博客根目录的默认分支，这里是main，有时也是master 7 pull_request: 8 9jobs: 10 deploy: 11 runs-on: ubuntu-20.04 12 concurrency: 13 group: ${{ github.workflow }}-${{ github.ref }} 14 steps: 15 - uses: actions/checkout@v2 16 with: 17 submodules: true 18 fetch-depth: 0 19 20 - name: Setup Hugo 21 uses: peaceiris/actions-hugo@v2 22 with: 23 hugo-version: \u0026#39;0.127.0\u0026#39; # 填写你的hugo版本，可用hugo version查看 24 extended: true # 如果你使用的不是extended版本的hugo，将true改为false 25 26 - name: Build 27 run: hugo --minify 28 29 - name: Deploy 30 uses: peaceiris/actions-gh-pages@v3 31 if: ${{ github.ref == \u0026#39;refs/heads/master\u0026#39; }} # 注意填写main或者master 32 with: 33 personal_token: ${{ secrets.HOGO}} # 如果secret取了其他名称，将MY_PAT替换掉 34 external_repository: chousinbin/chousinbin.github.io # 填写远程仓库，不一定是这个格式，按照自己的情况写 35 publish_dir: ./public 36 #cname: xinb.in # 填写你的自定义域名。如果没有用自定义域名，注释掉这行 4. 自定义域名 如果当前的网站自定义了域名，需要在 ./static/ 下创建 CNAME 文件，内容为域名，例如：\nxinb.in # 注意：不需要带协议和 www 子域名。 GitHub Pages 自定义域名需要将 CNAME 文件放在根目录，这样每当生成博客之后，CNAME 将复制到 ./public/ 目录下。通过自动部署之后 /public/ 内容复制到子仓库根目录中，相当于在根目录下。\n5. 自动部署 完成以上步骤之后，对网站做出更改后，仅需推送主仓库 (HugoBlog) ，就会自动调用 GitHub Actions 推送静态资源到子仓库 (chousinbin.github.io)。使用自动部署，将在子仓库生成一个名为 gh-pages 的新分支。需要在 Setting - Pages 中更新发布分支。\n","permalink":"https://xinb.in/posts/240706/","summary":"Hugo 生成的静态资源在 /public/* 下，为了方便部署，可以在 GitHub 创建两个仓库。 一个名为 HugoBlog 存储 Hugo 整体资源，另一个名为 chousinbin.github.io 存储 /public/* 文件，发布网站。 为了方便两个仓库的同","title":"GitHub Actions 自动部署 Hugo 博客"},{"content":" 注册 Boardcom 账号 选择右上角 VMware Cloud Foundation 点击 My Download 找到 VMware Workstation Pro (Windows/Linux), VMware Fusion (MacOS) 选择版本，勾选同意，开始下载 完成安装 ","permalink":"https://xinb.in/posts/240702/","summary":"vmware","title":"VMware个人免费授权"},{"content":"视频 VLC 开源，界面简洁，功能强大，多平台支持。\nPotPlayer 专注于 Windows 平台，具有优秀的硬件加速支持和高质量的音频 / 视频处理能力，特别是在高清和 4K 视频播放上表现突出。\nOBS Studio 工作站级别的跨平台录制、推流软件。\n图片 PicGo PicGo 是一个图床管理客户端，可与 Github、阿里云OSS 等服务搭建图床。\nSnipasta 截图工具，支持吸附等功能，不支持长截图。\n效率 Utools 快捷软件。\nToDo 任务管理。\nMozilla Thunderbird 开源跨平台的邮件管理客户端。\n网络 Clash 支持规则分流功能，GUI 美观，功能齐全（已停止维护）。\nSteam++ 开源加速小工具。\n文本 Typora 天下第一。\nVSCode 跨平台富文本编辑器。\nNotepad-- Notepad++ 作者言论不当。\nTexlive LaTeX 支持。\nSumatraPDF 轻便好用的 PDF 阅读器。\nPDFgear 阅读、编辑、转换、合并和跨设备签署PDF文件，且无需注册。\n支持 Windows, MacOS, iOS 平台。\n系统 VMware 虚拟机软件。\nWSL Windows Subsystem for Linux.\n开发 Dev-CPP 算法竞赛使用。\nNavicat 强大的数据库管理软件。\nGit 版本控制。\n7-Zip 简洁好用的压缩包软件。\n待整理 BCUninstaller Bypass Dism++ ipaDown Koodo-Reader LANDrop TBTray TrafficMonitor VSE Wub Fliqlo exif tool Xmind Zotero ","permalink":"https://xinb.in/posts/240628/","summary":"视频 VLC 开源，界面简洁，功能强大，多平台支持。 PotPlayer 专注于 Windows 平台，具有优秀的硬件加速支持和高质量的音频 / 视频处理能力，特别是在高清和 4K 视频播放上表","title":"好用软件整理"},{"content":"备战夏令营机试，创建此贴记录题解，激励刷题打卡。\n1768. 交替合并字符串 书写格式类似于归并排序\n1class Solution { 2public: 3 string mergeAlternately(string word1, string word2) { 4 string res = \u0026#34;\u0026#34;; 5 6 // 交替合并公共长度 7 int i = 0; 8 while(i \u0026lt; word1.size() \u0026amp;\u0026amp; i \u0026lt; word2.size()) { 9 res += word1[i]; 10 res += word2[i]; 11 i++; 12 } 13 14 // 收尾 15 while(i \u0026lt; word1.size()) res += word1[i++]; 16 while(i \u0026lt; word2.size()) res += word2[i++]; 17 18 return res; 19 } 20}; 1071. 字符串的最大公因子 1class Solution { 2public: 3 string gcdOfStrings(string str1, string str2) { 4 int len = str1.size(); 5 if(str1.size() \u0026gt; str2.size()) swap(str1, str2); 6 7 // 求最大，从大到小枚举长度 8 for(int i = len; i \u0026gt;= 1; i--) { 9 // 剪枝 10 if(str1.size() % i || str2.size() % i) continue; 11 12 string p = str1.substr(0, i); 13 bool st = true; 14 15 // 判断 p 能否除尽 str1，不能除尽就标记 16 for(int j = 0; j + i - 1 \u0026lt; str1.size(); j += i) 17 if(str1.substr(j, i) != p) { 18 st = 0; 19 break; 20 } 21 22 // 判断 p 能否除尽 str2 23 for(int j = 0; j + i - 1 \u0026lt; str2.size(); j += i) 24 if(str2.substr(j, i) != p) { 25 st = 0; 26 break; 27 } 28 29 // 都能除尽返回之大公因子串 30 if(st) return p; 31 } 32 return \u0026#34;\u0026#34;; 33 } 34}; 1431. 拥有最多糖果的孩子 1class Solution { 2public: 3 vector\u0026lt;bool\u0026gt; kidsWithCandies(vector\u0026lt;int\u0026gt;\u0026amp; candies, int extraCandies) { 4 // 求出当前最多糖果数 5 int maxc = 0; 6 for(int i = 0; i \u0026lt; candies.size(); i++) 7 maxc = max(maxc, candies[i]); 8 9 // 遍历 10 vector\u0026lt;bool\u0026gt; res; 11 for(int i = 0; i \u0026lt; candies.size(); i++) { 12 if(candies[i] + extraCandies \u0026gt;= maxc) 13 res.push_back(true); 14 else 15 res.push_back(false); 16 } 17 return res; 18 } 19}; 605. 种花问题 1class Solution { 2public: 3 bool canPlaceFlowers(vector\u0026lt;int\u0026gt;\u0026amp; flowerbed, int n) { 4 // 改变数组处理边界问题 5 flowerbed.insert(flowerbed.begin(), 0); // 从 vector 容器头部插入 6 flowerbed.push_back(0); 7 8 // 枚举判断，满足情况就种一朵花 9 for(int i = 1; i \u0026lt; flowerbed.size() - 1; i++) { 10 if(flowerbed[i] == 0 \u0026amp;\u0026amp; flowerbed[i - 1] == 0 \u0026amp;\u0026amp; flowerbed[i + 1] == 0) { 11 flowerbed[i] = 1; 12 n--; 13 } 14 } 15 16 return n \u0026lt;= 0; 17 } 18}; 345. 反转字符串中的元音字母 理解题面：找出这个串种的元音字母，翻转后替换原有的元音序列\n1class Solution { 2public: 3 string reverseVowels(string s) { 4 string ans = \u0026#34;\u0026#34;; 5 6 for(int i = 0; i \u0026lt; s.size(); i++) 7 if(s[i] == \u0026#39;a\u0026#39; || s[i] == \u0026#39;A\u0026#39; || s[i] == \u0026#39;e\u0026#39; || s[i] == \u0026#39;E\u0026#39; || 8 s[i] == \u0026#39;i\u0026#39; || s[i] == \u0026#39;I\u0026#39; || s[i] == \u0026#39;o\u0026#39; || s[i] == \u0026#39;O\u0026#39; || 9 s[i] == \u0026#39;u\u0026#39; || s[i] == \u0026#39;U\u0026#39;) 10 ans += s[i]; 11 12 reverse(ans.begin(), ans.end()); 13 14 int j = 0; 15 for(int i = 0; i \u0026lt; s.size(); i++) { 16 if(s[i] == \u0026#39;a\u0026#39; || s[i] == \u0026#39;A\u0026#39; || s[i] == \u0026#39;e\u0026#39; || s[i] == \u0026#39;E\u0026#39; || 17 s[i] == \u0026#39;i\u0026#39; || s[i] == \u0026#39;I\u0026#39; || s[i] == \u0026#39;o\u0026#39; || s[i] == \u0026#39;O\u0026#39; || 18 s[i] == \u0026#39;u\u0026#39; || s[i] == \u0026#39;U\u0026#39;) { 19 s[i] = ans[j++]; 20 } 21 } 22 23 return s; 24 } 25}; 283. 移动零 $\\bigstar$ 1class Solution { 2public: 3 void moveZeroes(vector\u0026lt;int\u0026gt;\u0026amp; nums) { 4 // j 寻找非零数 5 // 如果 i 指向非零则交换自己 6 int i = 0, j = 0; 7 while(j \u0026lt; nums.size()) { 8 if(nums[j] != 0) { 9 swap(nums[i], nums[j]); 10 i++; 11 } 12 j++; 13 } 14 } 15}; 392. 判断子序列 法一\n1class Solution { 2public: 3 bool isSubsequence(string s, string t) { 4 if(s.size() == 0) return true; 5 if(s.size() \u0026gt; t.size()) return false; 6 7 int j = 0; 8 for(int i = 0; i \u0026lt; t.size(); i++) { 9 if(s[j] == t[i]) j++; 10 } 11 12 return j == s.size(); 13 } 14}; 法二\n1class Solution { 2public: 3 bool isSubsequence(string s, string t) { 4 if(s.size() == 0) return true; 5 if(s.size() \u0026gt; t.size()) return false; 6 7 int i = 0, j = 0; 8 while(i \u0026lt; t.size() \u0026amp;\u0026amp; j \u0026lt; s.size()) { 9 if(s[j] == t[i]) j++; 10 i++; 11 } 12 13 return j == s.size(); 14 } 15}; 1732. 找到最高海拔 1class Solution { 2public: 3 int largestAltitude(vector\u0026lt;int\u0026gt;\u0026amp; gain) { 4 vector\u0026lt;int\u0026gt; res(gain.size() + 1); 5 6 res[0] = 0; 7 8 int ans = 0; 9 10 for(int i = 1; i \u0026lt;= gain.size(); i++) { 11 res[i] = res[i - 1] + gain[i - 1]; 12 ans = max(ans, res[i]); 13 } 14 15 return ans; 16 } 17}; 724. 寻找数组的中心下标 1class Solution { 2public: 3 int pivotIndex(vector\u0026lt;int\u0026gt;\u0026amp; nums) { 4 int n = nums.size(); 5 vector\u0026lt;int\u0026gt; ans(n + 1); 6 7 ans[0] = 0; 8 for(int i = 1; i \u0026lt;= n; i++) 9 ans[i] = nums[i - 1]; 10 11 for(int i = 1; i \u0026lt;= n; i++) 12 ans[i] += ans[i - 1]; 13 14 for(int i = 1; i \u0026lt;= n; i++) 15 if(ans[i - 1] == ans[n] - ans[i]) 16 return i - 1; 17 18 return -1; 19 } 20}; 1207. 独一无二出现的次数 1class Solution { 2public: 3 bool uniqueOccurrences(vector\u0026lt;int\u0026gt;\u0026amp; arr) { 4 unordered_map\u0026lt;int, int\u0026gt; cnt1; 5 6 for(int i = 0; i \u0026lt; arr.size(); i++) 7 cnt1[arr[i]] = 0; 8 9 for(int i = 0; i \u0026lt; arr.size(); i++) 10 cnt1[arr[i]]++; 11 12 unordered_map\u0026lt;int, int\u0026gt; cnt2; 13 14 for(auto p : cnt1) { 15 cnt2[p.second] = 0; 16 } 17 18 for(auto p : cnt1) { 19 cnt2[p.second]++; 20 if(cnt2[p.second] \u0026gt; 1) return false; 21 } 22 23 return true; 24 } 25}; 746. 使用最小花费爬楼梯 1class Solution { 2public: 3 int minCostClimbingStairs(vector\u0026lt;int\u0026gt;\u0026amp; cost) { 4 int n = cost.size(); 5 6 vector\u0026lt;int\u0026gt; dp(n + 1); 7 8 dp[0] = dp[1] = 0; 9 for(int i = 2; i \u0026lt;= n; i++) 10 dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]); 11 12 return dp[n]; 13 } 14}; 238. 除自身意外数组的乘积 预处理前缀和与后缀和，注意边界。\n除去 i 下标元素的乘积 = 0 至 i - 1 区间的前缀和 * i + 1 至 n - 1 区间的后缀和。\n1class Solution { 2public: 3 vector\u0026lt;int\u0026gt; productExceptSelf(vector\u0026lt;int\u0026gt;\u0026amp; nums) { 4 int n = nums.size(); 5 vector\u0026lt;int\u0026gt; L(n + 1); 6 vector\u0026lt;int\u0026gt; R(n + 1); 7 8 L[0] = 1; 9 for(int i = 1; i \u0026lt;= n; i++) 10 L[i] = L[i - 1] * nums[i - 1]; 11 12 R[n] = 1; 13 for(int i = n - 1; i \u0026gt;= 0; i--) 14 R[i] = R[i + 1] * nums[i]; 15 16 vector\u0026lt;int\u0026gt; ans; 17 18 for(int i = 1; i \u0026lt;= nums.size(); i++) 19 ans.push_back(L[i - 1] * R[i]); 20 21 return ans; 22 } 23}; 334. 递增三元子序列 预处理开头至每个元素区间内的最小值，和每个元素至结尾区间内的最大值。\n遍历每个元素的大小与左区间最小值和右区间最大值进行比较。\n1class Solution { 2public: 3 bool increasingTriplet(vector\u0026lt;int\u0026gt;\u0026amp; nums) { 4 if(nums.size() \u0026lt; 3) return false; 5 6 vector\u0026lt;int\u0026gt; minNum(nums.size()); 7 minNum[0] = nums[0]; 8 for(int i = 1; i \u0026lt; nums.size(); i++) 9 minNum[i] = min(minNum[i - 1], nums[i]); 10 11 vector\u0026lt;int\u0026gt; maxNum(nums.size()); 12 maxNum[nums.size() - 1] = nums[nums.size() - 1]; 13 for(int i = nums.size() - 2; i \u0026gt;= 0; i--) 14 maxNum[i] = max(maxNum[i + 1], nums[i]); 15 16 for(int i = 1; i \u0026lt; nums.size() - 1; i++) 17 if(nums[i] \u0026gt; minNum[i - 1] \u0026amp;\u0026amp; nums[i] \u0026lt; maxNum[i + 1]) 18 return true; 19 20 return false; 21 } 22}; 443. 压缩字符串 1class Solution { 2public: 3 int compress(vector\u0026lt;char\u0026gt;\u0026amp; chars) { 4 vector\u0026lt;char\u0026gt; res; 5 6 for(int i = 0, j = 0; i \u0026lt; chars.size(); i++) { 7 j = i; 8 // 双指针 i 指向相同元素开头，j 指向相同元素结尾 9 while(j \u0026lt; chars.size() \u0026amp;\u0026amp; chars[i] == chars[j]) j++; 10 int len = j - i; 11 res.push_back(chars[i]); 12 13 if(len \u0026gt; 1) { 14 string s = to_string(len); 15 for(int i = 0; i \u0026lt; s.size(); i++) 16 res.push_back(s[i]); 17 } 18 19 i = j - 1; 20 } 21 22 chars = res; 23 return res.size(); 24 } 25}; 11. 盛最多水的容器 木桶容量由短板决定, 移动长板的话, 水面高度不可能再上升, 而宽度变小了, 所以只有通过移动短板, 才有可能使水位上升。\n1class Solution { 2public: 3 int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { 4 int i = 0, j = height.size() - 1; 5 int res = -1; 6 7 while(i \u0026lt; j) { 8 res = max(res, min(height[i], height[j]) * (j - i)); 9 10 if(height[i] \u0026gt; height[j]) j--; 11 else i++; 12 } 13 14 return res; 15 } 16}; 1137. 第 N 个泰波那契数 1class Solution { 2public: 3 int tribonacci(int n) { 4 if(n == 0) return 0; 5 if(n \u0026lt;= 2) return 1; 6 7 vector\u0026lt;int\u0026gt; dp(n + 1); 8 9 dp[0] = 0, dp[1] = dp[2] = 1; 10 11 for(int i = 3; i \u0026lt;= n; i++) 12 dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]; 13 14 return dp[n]; 15 } 16}; 1679. K 和数对的最大数目 哈希做法\n1class Solution { 2public: 3 int maxOperations(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { 4 int res = 0; 5 unordered_map \u0026lt;int, int\u0026gt; cnt; 6 7 for(auto num : nums) { 8 if(cnt[k - num] \u0026gt; 0) { 9 res++; 10 cnt[k - num]--; 11 } 12 else { 13 cnt[num]++; 14 } 15 } 16 17 return res; 18 } 19}; 双指针做法\n1class Solution { 2public: 3 int maxOperations(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { 4 int res = 0; 5 6 sort(nums.begin(), nums.end()); 7 8 int i = 0, j = nums.size() - 1; 9 10 while(i \u0026lt; j) { 11 int sum = nums[i] + nums[j]; 12 if(sum == k) { 13 res++; 14 i++; 15 j--; 16 } else if(sum \u0026gt; k) j--; 17 else i++; 18 } 19 20 return res; 21 } 22}; 494. 目标和 1class Solution { 2public: 3 int cnt = 0; 4 5 // u 表示枚举到的位数 6 // sum 表示当前位数的表达式之和 7 void dfs(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target, int u, int sum) { 8 if (u == nums.size()) { 9 if(sum == target) cnt++; 10 } else { 11 dfs(nums, target, u + 1, sum + nums[u]); 12 dfs(nums, target, u + 1, sum - nums[u]); 13 } 14 } 15 16 int findTargetSumWays(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { 17 dfs(nums, target, 0, 0); 18 return cnt; 19 } 20}; 643. 子数组最大平均数 I 1class Solution { 2public: 3 double findMaxAverage(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { 4 int n = nums.size(); 5 6 int sum = 0; 7 for(int i = 0; i \u0026lt; k; i++) 8 sum += nums[i]; 9 10 int res = sum; 11 for(int i = k; i \u0026lt; n; i++) { 12 sum = sum + nums[i] - nums[i - k]; 13 res = max(res, sum); 14 } 15 16 return res * 1.0 / k; 17 } 18}; 1456. 定长子串中元音的最大数目 1class Solution { 2public: 3 bool check(char a) { 4 if(a == \u0026#39;a\u0026#39; || a == \u0026#39;e\u0026#39; || a == \u0026#39;i\u0026#39; || a == \u0026#39;o\u0026#39; || a == \u0026#39;u\u0026#39;) 5 return true; 6 return false; 7 } 8 9 int maxVowels(string s, int k) { 10 int sum = 0; 11 for(int i = 0; i \u0026lt; k; i++) 12 if(check(s[i])) 13 sum++; 14 15 int res = sum; 16 for(int i = k; i \u0026lt; s.size(); i++) { 17 if(check(s[i - k])) sum--; 18 if(check(s[i])) sum++; 19 res = max(res, sum); 20 } 21 22 return res; 23 } 24}; 1004. 最大连续 1 的个数 III 1class Solution { 2public: 3 /* 4 cnt 记录当前区间中 0 的个数 5 res 记录区间中不超过 k 个零的前提下，区间的最大长度 6 i 是区间右端点 7 区间中 0 的数量大于 k 之后，就要从左边进行收缩，直到区间内 0 个数小于等于 k 8 */ 9 int longestOnes(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { 10 int res = 0; 11 for(int i = 0, j = 0, cnt = 0; i \u0026lt; nums.size(); i++) { 12 if(nums[i] == 0) cnt++; 13 14 while(cnt \u0026gt; k) { 15 if(nums[j] == 0) cnt--; 16 j++; 17 } 18 19 res = max(res, i -j + 1); 20 } 21 22 return res; 23 } 24}; 2390. 从字符串中移除星号 1class Solution { 2public: 3 string removeStars(string s) { 4 stack\u0026lt;char\u0026gt; st; 5 for(int i = 0; i \u0026lt; s.size(); i++) 6 if(s[i] == \u0026#39;*\u0026#39;) st.pop(); 7 else st.push(s[i]); 8 9 string res; 10 while(!st.empty()) { 11 res += st.top(); 12 st.pop(); 13 } 14 15 reverse(res.begin(), res.end()); 16 return res; 17 } 18}; 735. 小行星碰撞 1class Solution { 2public: 3 vector\u0026lt;int\u0026gt; asteroidCollision(vector\u0026lt;int\u0026gt;\u0026amp; asteroids) { 4 stack\u0026lt;int\u0026gt; s; 5 for(auto c : asteroids) { 6 if (c \u0026lt; 0) { 7 while(!s.empty() \u0026amp;\u0026amp; s.top() \u0026gt; 0 \u0026amp;\u0026amp; s.top() \u0026lt; abs(c)) 8 s.pop(); 9 if (s.empty() || s.top() \u0026lt; 0) s.push(c); 10 if (!s.empty() \u0026amp;\u0026amp; s.top() == abs(c)) s.pop(); 11 } else { 12 s.push(c); 13 } 14 15 } 16 17 vector\u0026lt;int\u0026gt; res; 18 while(!s.empty()) { 19 res.push_back(s.top()); 20 s.pop(); 21 } 22 23 reverse(res.begin(), res.end()); 24 25 return res; 26 } 27}; 933. 最近的请求次数 1class RecentCounter { 2public: 3 queue\u0026lt;int\u0026gt; q; 4 RecentCounter() { 5 6 } 7 8 int ping(int t) { 9 q.push(t); 10 while (t - q.front() \u0026gt; 3000) q.pop(); 11 return q.size(); 12 } 13}; 14 15/** 16 * Your RecentCounter object will be instantiated and called as such: 17 * RecentCounter* obj = new RecentCounter(); 18 * int param_1 = obj-\u0026gt;ping(t); 19 */ 104. 二叉树的最大深度 1/** 2 * Definition for a binary tree node. 3 * struct TreeNode { 4 * int val; 5 * TreeNode *left; 6 * TreeNode *right; 7 * TreeNode() : val(0), left(nullptr), right(nullptr) {} 8 * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} 9 * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} 10 * }; 11 */ 12class Solution { 13public: 14 int maxDepth(TreeNode* root) { 15 if(root == NULL) return 0; 16 return max(maxDepth(root-\u0026gt;left), maxDepth(root-\u0026gt;right)) + 1; 17 } 18}; 198. 打家劫舍 1class Solution { 2public: 3 int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums) { 4 int n = nums.size(); 5 6 if (n == 0) return 0; 7 if (n == 1) return nums[0]; 8 9 vector\u0026lt;int\u0026gt; dp(n + 1); 10 dp[0] = nums[0]; 11 dp[1] = max(nums[0], nums[1]); 12 13 for(int i = 2; i \u0026lt; n; i++) 14 dp[i] = max(nums[i] + dp[i - 2], dp[i - 1]); 15 16 return dp[n - 1]; 17 } 18}; ","permalink":"https://xinb.in/posts/leetcode-75/","summary":"LeetCode 75 题解","title":"LeetCode 75"},{"content":"今天是 6 月 1 日，来到东北大学参加第十五届蓝桥杯国赛。\n说实话，国赛的准备没有省赛充分，上周学校的几门课程已经结课了，挺多时间在忙课程的作业和期末考试。\n早上不到 7 点钟就自然醒了，简单洗漱过后就打车去东大东门了。还没进学校就感到了这所学校很气派，东门有一个石牌，张学良题词的“东北大学”，信息学馆离东门很近，分为 AB 座。我的考场在 A408。东大每个教室外门旁边的墙壁上都有电子屏幕显示教室使用情况，基础设施比我本科学校好太多了。\n8:30 开始进场，进场签到之后，每人领取一袋补给。包含 2 瓶矿泉水，1 袋牛奶，2 个面包，1 个鸡蛋。\n我所在的机房应该是 2015 年更新的，DELL 主机采用的四代 i7 处理器。教室前后各有一个投影仪，防止传统机房后排同学看不到投影。椅子是实木的小椅子，很稳当不会晃。\n13 点交卷之后，走着去了第二食堂，到档口发现支付需要使用校内支付码，于是问了我前面的本校同学代刷，点了一份牛肉干拌面。\n吃完扫了一辆哈喽小车，背着我的书包在校园内转了一圈，学校挺大，建筑也气派。\n不说了，赶紧去沈阳南站返航了\n2024 年 6 月 1 日 14:57:07 于沈阳\n","permalink":"https://xinb.in/posts/240601/","summary":"蓝桥杯国赛","title":"蓝桥杯国赛在 NEU"},{"content":" 缺少发现美的眼睛。\n无论身处何处，在我们身边都会有美丽的风景，可以是日出与日落的一刻钟、可以是清新幽静的公园、可以是路边的一草一木\u0026hellip;\n可是，我们好像都很“忙”。\n在路上忙于奔波？无暇看路途的风景？\n在学校忙于学业？无时间出去走一走？\n其实，只要在路途中停一下，走慢一点，看向窗外，你会发现美景一直在，只要去看。\n景在路上，你看便是。\n忙忙忙 忙忙忙\n忙是为了自己的理想\n还是为了不让别人失望\n盲盲盲 盲盲盲\n盲的已经没有主张\n盲的已经失去方向\n忙忙忙 盲盲盲\n忙的分不清欢喜还是忧伤\n忙的没有时间痛哭整一场\n","permalink":"https://xinb.in/posts/240331/","summary":"忙与盲","title":"忙与盲"},{"content":"Git $everything\\ is\\ local$\n一、Git概述 Git是一个免费的、开源的分布式版本控制系统，可以快速高效的处理从小型到大型的各种项目。\nGit易于学习， 占用空间小，性能快如闪电。它优于 SCM 工具，如 Subversion、CVS、Perforce 和 ClearCase，具有廉价的本地分支、方便的暂存区域和多个工作流等功能。\n1.1Git历史 Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。\nLinus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？\n事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！\n你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。\n不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。\n安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。\nLinus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：\nLinus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。\nGit迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。\n历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。\n(摘录于廖雪峰官网Linux教程)\n1.2版本控制 团队开发需要记录项目版本以及正确的版本控制，Git版本控制软件由此而来。\n1.3版本控制工具 集中式版本控制工具 CVS、SVN（subversion）、VSS\u0026hellip;\u0026hellip;\n集中化的版本控制系统诸如CVS、SVN等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。\n优点是每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统，要远比在各个客户端上维护本地数据库来得轻松容易。\n缺点是中央服务器的单点故障。如果服务器宕机一小时，那么在这一小时内，准都无法提交更新，也就无法协同工作。\n分布式版本控制工具 Git、Mercurial、Bazaar、Darcs\u0026hellip;\u0026hellip;\n像Git这种分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来（本地库）。这样任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份。\n分布式的版本控制系统出现之后，解决了集中式版本控制系统的缺陷：\n服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的） 每个客户端保存的也都是整个完整的项目（包含历史记录，更加安全） 1.4Git工作机制 只有把代码提交到本地库，才会产生历史版本。\n本地库→git push→远程库\n1.5代码托管平台 代码托管中心是基于网络服务器的远程代码仓库，一般称为远程库。\n局域网：Gitlab\n互联网：Github、Gitee码云\n二、Git安装 Git官网：https://git-scm.com/\n默认选项安装\n查看Git版本\n1ChouS@DESKTOP-78VSLED MINGW64 ~ 2$ git --version 3git version 2.37.0.windows.1 三、Git常用命令 大部分命令与Linux通用。\n命令名称 作用 git config \u0026ndash;global user.name 用户名 设置用户签名 git config \u0026ndash;global user.email 邮箱 设置用户签名 git init 初始化本地库 git status 查看本地库状态 git add 文件名 添加到暂存区 git rm \u0026ndash;cached 文件名 从暂存区删除 git commit -m \u0026ldquo;版本信息\u0026rdquo; 文件名 提交到本地库 git reflog 查看历史纪录 git reset \u0026ndash;hard 版本号 版本穿梭 git log 查看当前版本详细日志 3.1用户签名 设置用户签名 git config --global user.name 用户签名 git config --global user.email 用户邮箱 查看用户签名 注意：\n签名的作用是区分不同操作者的身份。用户签名信息在每一个版本的提交信息中能够看到，以此确定本次提交的谁做的。 Git首次安装必须设置一下用户签名，否则无法提交代码。 这里设置的用户签名的用户名和邮箱与将来登录代码托管平台的账号没有任何关系。 3.2初始化本地库 git init 在项目根文件夹中右键选择git bush ，输入上命令，完成初始化本地库。\n3.3查看本地库状态 git status 红名文件说明是改动的文件，未被添加到暂存区。\n绿名文件，说明该文件状态已经从工作区add到暂存区，说明Git追踪到了该文件。\n3.4添加到暂存区 添加到暂存区 git add 文件名 批量添加到暂存区 添加多个文件，文件之间以空格隔开\ngit add file1 file2 file3 添加指定文件夹下的文件或者指定文件夹下指定格式文件\ngit add 算法/* //把算法文件夹下的全部文件添加到暂存区 git add 算法/*.md //把算法文件夹下.md格式的文件添加到暂存区 添加所有文件\ngit add . git add --all 从暂存区删除 添加到暂存区还不会被版本控制记录，可以进行从暂存区删除命令。\ngit rm --cached 文件名 这个删除只是从暂存区删除，不会删除工作区的源文件。\n3.5提交到本地库 git commit -m \u0026#34;版本信息\u0026#34; 文件名 执行该命令后，把暂存区的文件提交到本地库。此时，文件被版本控制记录。\n3.6查看历史日志 git reflog 显示当前项目的所有历史版本，以及对应版本的版本号前七位（如本数据c16588d）。\n3.7查看详细历史日志 1ChouS@DESKTOP-78VSLED MINGW64 /e/Github/Notes (master) 2$ git log 3commit b2325b3a938da90867449087ef4abfaaf2b96637 (HEAD -\u0026gt; master, notes/master) 4Author: SinbinChou \u0026lt;chousinbin@163.com\u0026gt; 5Date: Wed Jul 20 21:57:31 2022 +0800 6 7 2022-07-20 显示当前项目当前版本的详细日志信息。比如：完整的版本号、提交者的签名、提交时间、版本名等。\n3.8修改文件 修改文件 修改newfile文件第一行尾添加了222。\n修改后的状态 再次查看状态，我们发现有提示modified:文件名，这种状态说明此文件被修改过了。\n另外这个提示是红色字体，所以这个修改的文件还没有被添加到暂存区，需要对此文件进行添加到暂存区。\n添加到暂存区后的状态 添加到暂存区后，再次查看状态，绿色状态表明：当前文件是被修改且添加到暂存区后未被提交到本地库的文件。\n提交到本地库 提交到本地库后返回操作者提交的版本信息、文件修改的数量、行数的插入数与删除数。\n我们明明是在一行的结尾添加了数字$2$，为什么返回的信息是一行插入和一行删除呢？\n因为Git是按照行来编辑的，在修改文件信息时，先删除当前行，再把修改后的信息插入到原来的位置。\n提交到本地库后的状态 世界恢复了原有的平静。\n虽然我们对此项目的一个文件可能进行多个版本的修改，但是本地源文件只有一个，版本控制由Git掌管。\n3.9版本穿梭 git reset --hard 版本号 先找到版本号（前7位就可以）\n选中要穿梭到的版本号，右击复制，执行版本穿梭命令。\n查看穿梭后的日志信息\n明显看到当前指向first version版本。最顶行多出一行日志记录我们进行了版本穿梭。说明版本穿梭也会被Git的日志记录，但版本号不会新增。\n四、Git分支操作 4.1什么是分支 在版本控制过程中，同时推进多个任务，为每廷务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。（分支底层其实也是指针的引用）\n4.2分支的好处 同时并行推进多个功能开发，提高开发效率。\n各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。\n4.3分支的操作 命令名称 作用 git branch 分支名 创建分支 git branch -v 查看分支 git checkout 分支名 切换分支 git merge 分支名 把指定的分支合并到当前分支上 查看分支 git branch -v 创建分支 git branch 分支名 创建一个名为hot-fix的紧急修复分支。\n创建的新分支，会克隆当前分支的的所有状态和信息，比如：历史版本信息等等。\n切换分支 git checkout 分支名 切换成功后会返回切换成功信息，下一个提示符的蓝色括号由原来的master变成了hot-fix。\n同时日志会记录分支切换信息。\n分支修改文件 直接调用vim对最新版本的newfile.md文件进行修改。修改之后的状态与在同一个分支下修改文件相似，这里省略图文介绍，详细参考上文3.8修改文件。之后的步骤是：添加到暂存区、提交到本地库。\n在修改分支提交的版本我们命名为hot-fix first version。\n合并分支 git merge 分支名 合并前先把项目的分支切换到需要合并到的分支上**（master)**\n执行合并命令\n冲突合并 产生冲突的原因：合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改。Git无法替我们决定使用哪一个。必须认为决定新代码的内容。\n模拟冲突合并：\n因为上一步我们刚刚把hot-fix中的 first version合并到mater中来，所以此时mater分支newfile的内容与hot-fix中newfile.md的内容一样。\n我们先把master中的newfile最后一行尾加入master test。再进行添加和提交。版本命名master test。\n再把分支切换到hot-fix，此时内容还未受到master分支的修改而修改。\n这时我们把hot-fix中的newfile的倒数第二行末加上hot-fix test。\n然后添加、提交。版本名为hotfix-version。切换回master分支，执行合并分支。\n此时报错并且当前状态为在master分支上，并且正在合并分支，需要我们人为进入vim选择合并。\n\u0026laquo;\u0026laquo;\u0026laquo; HEAD 与======之间的内容表示是当前mater分支的修改内容。 =======与\u0026raquo;\u0026raquo;\u0026raquo;\u0026gt; hot-fix之间的内容表示hot-fix分支的修改内容。\n我们需要手动修改内容并且删除多余的提示符号。\n上图是人工手动修改合并后的信息，保留了两个处在不同分支的操作者对同一文件的修改。\n保存完文件之后，还要把修改完的文件添加到暂存区以及提交到工作区的一系列操作，注意在手动合并后的提交到本地库的命令中不需要带文件名。\n提交完成后，状态变为master。至此我们通过手动合并分支解决了代码冲突。\n注意：合并分支只会修改合并到分支的文件的内容，从哪合并来的哪个分支通过合并操作不会被修改。\n五、Github远程库操作 5.1配置SSH 设置用户签名\n检查是否存在SSH Key\n1ChouS@DESKTOP-78VSLED MINGW64 / 2$ cd ~/.ssh 3 4ChouS@DESKTOP-78VSLED MINGW64 ~/.ssh 5$ ls 6id_rsa id_rsa.pub known_hosts known_hosts.old 存在id_rsa.pub和id_rsa说明存在SSH密钥。\n如果没有，则执行生成SSH Key\n1ChouS@DESKTOP-78VSLED MINGW64 ~/.ssh 2$ ssh -keygen -t rsa -C \u0026#34;邮箱地址\u0026#34; 查看SSH Key\n1ChouS@DESKTOP-78VSLED MINGW64 ~/.ssh 2$ cat id_rsa.pub 3ssh-rsa 4以下为密钥内容，此处不做展示。 到Github配置添加密钥\n登陆Github-右上角头像-settings-SSH and GPG keys-add。\n配置好SSH后,在自己的电脑Github会自动与远程库保持通信。\n5.2创建远程仓库 Repository\n公网访问仓库名称为 username.github.io，每个账号只有一个。\n非公网访问仓库名称用户自定义，有很多个供我们使用。\n5.3远程仓库操作 创建远程仓库别名 操作命令 操作名称 git remote -v 查看当前所有远程地址的别名 git remote add 别名 远程地址 设置远程地址的别名 查看远程地址别名有两行，说明这个别名可以用于推送、拉取、克隆等。\n推送本地库代码到远程库 git push 别名/远程链接 分支 推送的最小单位是分支，需要指定推送哪一个分支。\n拉取远程库到本地库 git pull 别名 分支 当本地库与远程库的项目文件内容不一致时，需要先用Pull拉取到本地，更新本地库与远程库保持一致。\n克隆远程仓库到本地 git clone 远程地址 克隆会自动完成：1、拉取代码 2、初始化本地仓库 3、创建别名\n当到一个新环境管理自己的或上级的项目需要克隆到本地以实现初始化和拉取最新代码。\n5.4Github界面介绍 功能名称 作用 Code 展示项目源码，提供源码Clone和打包下载。 Issues 讨论区，可以对项目进行各种提问。我们每个人都可以在本区提出issuse。状态Open：讨论中状态Closed：关闭该帖，已经解决问题。 Pull requests 从Fork的项目发起向原项目合并请求 fork 原项目的拷贝数。 watch 关注项目的变化，如果别人提交了pull、request、发起了issue，在通知中心会收到消息。 star 类似于点赞，表示项目受欢迎度。 branch 分支 tag 标签 5.5Branch与Fork的区别 Fork属于远程托管平台的功能，并不属于Git的branch。\nFork是一个新的仓库，可以随便开分支，只要最后不乱 pull request 乱合并到原项目就不会出事； branch 其实只是一个分支，比一个仓库的范围要小得多，你实际上还是处于同一个项目仓库中。\nPull Request：从Fork过衍生出的新项目向原项目发起合并推送请求。\n5.6顶级域名 申请顶级域名并且指向username.github.io，会使之变为类似www.username.com等高大尚的地址。\n申请渠道 阿里云 腾讯云 GoDaddy freenom 从顶级域名渠道配置指向我们的GitHub地址后，要从GitHub的仓库setting中的Custom domain输入我们购买好的顶级域名，这样顶级域名就配置完成了。\n5.7版本比较 在原项目的网址后面加上\\compare可以访问该项目的版本比较页面，另外也有插件可以使得源码比较起来直观。\n","permalink":"https://xinb.in/posts/git/","summary":"Git","title":"Git"},{"content":"今天是 2022 年 6 月 8 日，是大学第一个暑假的一个礼拜，这个暑假我躲回了老家，我的家乡位于燕山南麓，滦河之畔。现在是 21 时，此时的乡村已经停止了喧嚣。我在二楼卧室里，挑着良亮牌老式台灯（里面装的是乒乓球大小的白炽灯），其散发着黄色的光芒。桌子上除了这把老台灯，还有一个轻薄本、一部倒扣着的手机、一把 68 键的机械键盘、一个键盘手托和一只鼠标。此时我正在观看学习 AcWing 网站上闫雪灿的算法基础课的动态规划部分。\n就在这时，我忽然听到一声汽笛声，这是我从小学到大学，从老院到新院，只要我在家就能听到的大秦线上运煤火车的汽笛声。随之而来的就是火车轮毂撞击火车轨道接缝的咣当声，火车很长。我的小学就在铁路旁边，小时候在教室的窗边数过，大约一百多节，所以咣当声会持续几分钟。其声势浩浩荡荡，如同万马奔腾，令人振奋。\n现在是大学学生，除了寒暑假难得回家。甚至以后工作，当一名程序员，除了年假，就几乎不能回家了吧。突发其感，故而记之。\n","permalink":"https://xinb.in/posts/220608/","summary":"深夜的一声汽笛唤起了我的乡愁","title":"深夜的一声汽笛"},{"content":"👋Hi, my name is Xinbin. I was born in the Year of the Horse in a county town situated at the southern foot of Yanshan Mountain. Currently, I am pursuing my college education in Dalian.\nBackground Dalian Jiaotong University, Software Engineering, 2021.09 - 2025.07\nAcademic Score: 92.42 / 100 (Ranked 2nd out of 129)\nEnglish Proficiency: CET-6\nContact Please feel free to email chousinbin at Gmail or 163 email services.\nAwards 2022: First Prize in Provincial C/C++ Competition, Lanqiao Cup Third Prize in Liaoning College Student Programming Contest 2023: First-Class Outstanding Student Comprehensive Scholarship at Dalian Jiaotong University (1/129) Outstanding Student at Dalian Jiaotong University 2024: First Prize in Provincial C/C++ Competition, Lanqiao Cup Skills Languages: Java, C/C++, LaTeX, Markdown Frames: Hugo Tools: Git/GitHub, PicGo, Linux, Clash Hobbies Running Hiking Fishing Denim Tea ","permalink":"https://xinb.in/about/","summary":"👋Hi, my name is Xinbin. I was born in the Year of the Horse in a county town situated at the southern foot of Yanshan Mountain. Currently, I am pursuing my college education in Dalian.\nBackground Dalian Jiaotong University, Software Engineering, 2021.09 - 2025.07\nAcademic Score: 92.42 / 100 (Ranked 2nd out of 129)\nEnglish Proficiency: CET-6\nContact Please feel free to email chousinbin at Gmail or 163 email services.","title":"About"}]