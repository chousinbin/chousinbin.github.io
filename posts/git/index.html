<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Git | Xinbin</title>
<meta name=keywords content="Git,GitHub"><meta name=description content="Git"><meta name=author content><link rel=canonical href=https://xinb.in/posts/git/><link crossorigin=anonymous href=/assets/css/stylesheet.dc93518033dc7558b12a78da68e3023c006f3bbf869f8ffb9159ddb737a9f917.css integrity="sha256-3JNRgDPcdVixKnjaaOMCPABvO7+Gn4/7kVndtzep+Rc=" rel="preload stylesheet" as=style><link rel=icon href=https://xinb.in/icon.png><link rel=icon type=image/png sizes=16x16 href=https://xinb.in/icon.png><link rel=icon type=image/png sizes=32x32 href=https://xinb.in/icon.png><link rel=apple-touch-icon href=https://xinb.in/icon.png><link rel=mask-icon href=https://xinb.in/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://xinb.in/posts/git/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@100..900&display=swap" rel=stylesheet><link href=https://fonts.cdnfonts.com/css/code-new-roman rel=stylesheet><meta property="og:title" content="Git"><meta property="og:description" content="Git"><meta property="og:type" content="article"><meta property="og:url" content="https://xinb.in/posts/git/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-21T15:33:39+08:00"><meta property="article:modified_time" content="2022-07-21T15:33:39+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Git"><meta name=twitter:description content="Git"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"博客","item":"https://xinb.in/posts/"},{"@type":"ListItem","position":2,"name":"Git","item":"https://xinb.in/posts/git/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Git","name":"Git","description":"Git","keywords":["Git","GitHub"],"articleBody":"Git $everything\\ is\\ local$\n一、Git概述 Git是一个免费的、开源的分布式版本控制系统，可以快速高效的处理从小型到大型的各种项目。\nGit易于学习， 占用空间小，性能快如闪电。它优于 SCM 工具，如 Subversion、CVS、Perforce 和 ClearCase，具有廉价的本地分支、方便的暂存区域和多个工作流等功能。\n1.1Git历史 Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。\nLinus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？\n事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！\n你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。\n不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。\n安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。\nLinus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：\nLinus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。\nGit迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。\n历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。\n(摘录于廖雪峰官网Linux教程)\n1.2版本控制 团队开发需要记录项目版本以及正确的版本控制，Git版本控制软件由此而来。\n1.3版本控制工具 集中式版本控制工具 CVS、SVN（subversion）、VSS……\n集中化的版本控制系统诸如CVS、SVN等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。\n优点是每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统，要远比在各个客户端上维护本地数据库来得轻松容易。\n缺点是中央服务器的单点故障。如果服务器宕机一小时，那么在这一小时内，准都无法提交更新，也就无法协同工作。\n分布式版本控制工具 Git、Mercurial、Bazaar、Darcs……\n像Git这种分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来（本地库）。这样任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份。\n分布式的版本控制系统出现之后，解决了集中式版本控制系统的缺陷：\n服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的） 每个客户端保存的也都是整个完整的项目（包含历史记录，更加安全） 1.4Git工作机制 只有把代码提交到本地库，才会产生历史版本。\n本地库→git push→远程库\n1.5代码托管平台 代码托管中心是基于网络服务器的远程代码仓库，一般称为远程库。\n局域网：Gitlab\n互联网：Github、Gitee码云\n二、Git安装 Git官网：https://git-scm.com/\n默认选项安装\n查看Git版本\n1ChouS@DESKTOP-78VSLED MINGW64 ~ 2$ git --version 3git version 2.37.0.windows.1 三、Git常用命令 大部分命令与Linux通用。\n命令名称 作用 git config –global user.name 用户名 设置用户签名 git config –global user.email 邮箱 设置用户签名 git init 初始化本地库 git status 查看本地库状态 git add 文件名 添加到暂存区 git rm –cached 文件名 从暂存区删除 git commit -m “版本信息” 文件名 提交到本地库 git reflog 查看历史纪录 git reset –hard 版本号 版本穿梭 git log 查看当前版本详细日志 3.1用户签名 设置用户签名 git config --global user.name 用户签名 git config --global user.email 用户邮箱 查看用户签名 注意：\n签名的作用是区分不同操作者的身份。用户签名信息在每一个版本的提交信息中能够看到，以此确定本次提交的谁做的。 Git首次安装必须设置一下用户签名，否则无法提交代码。 这里设置的用户签名的用户名和邮箱与将来登录代码托管平台的账号没有任何关系。 3.2初始化本地库 git init 在项目根文件夹中右键选择git bush ，输入上命令，完成初始化本地库。\n3.3查看本地库状态 git status 红名文件说明是改动的文件，未被添加到暂存区。\n绿名文件，说明该文件状态已经从工作区add到暂存区，说明Git追踪到了该文件。\n3.4添加到暂存区 添加到暂存区 git add 文件名 批量添加到暂存区 添加多个文件，文件之间以空格隔开\ngit add file1 file2 file3 添加指定文件夹下的文件或者指定文件夹下指定格式文件\ngit add 算法/* //把算法文件夹下的全部文件添加到暂存区 git add 算法/*.md //把算法文件夹下.md格式的文件添加到暂存区 添加所有文件\ngit add . git add --all 从暂存区删除 添加到暂存区还不会被版本控制记录，可以进行从暂存区删除命令。\ngit rm --cached 文件名 这个删除只是从暂存区删除，不会删除工作区的源文件。\n3.5提交到本地库 git commit -m \"版本信息\" 文件名 执行该命令后，把暂存区的文件提交到本地库。此时，文件被版本控制记录。\n3.6查看历史日志 git reflog 显示当前项目的所有历史版本，以及对应版本的版本号前七位（如本数据c16588d）。\n3.7查看详细历史日志 1ChouS@DESKTOP-78VSLED MINGW64 /e/Github/Notes (master) 2$ git log 3commit b2325b3a938da90867449087ef4abfaaf2b96637 (HEAD -\u003e master, notes/master) 4Author: SinbinChou 5Date: Wed Jul 20 21:57:31 2022 +0800 6 7 2022-07-20 显示当前项目当前版本的详细日志信息。比如：完整的版本号、提交者的签名、提交时间、版本名等。\n3.8修改文件 修改文件 修改newfile文件第一行尾添加了222。\n修改后的状态 再次查看状态，我们发现有提示modified:文件名，这种状态说明此文件被修改过了。\n另外这个提示是红色字体，所以这个修改的文件还没有被添加到暂存区，需要对此文件进行添加到暂存区。\n添加到暂存区后的状态 添加到暂存区后，再次查看状态，绿色状态表明：当前文件是被修改且添加到暂存区后未被提交到本地库的文件。\n提交到本地库 提交到本地库后返回操作者提交的版本信息、文件修改的数量、行数的插入数与删除数。\n我们明明是在一行的结尾添加了数字$2$，为什么返回的信息是一行插入和一行删除呢？\n因为Git是按照行来编辑的，在修改文件信息时，先删除当前行，再把修改后的信息插入到原来的位置。\n提交到本地库后的状态 世界恢复了原有的平静。\n虽然我们对此项目的一个文件可能进行多个版本的修改，但是本地源文件只有一个，版本控制由Git掌管。\n3.9版本穿梭 git reset --hard 版本号 先找到版本号（前7位就可以）\n选中要穿梭到的版本号，右击复制，执行版本穿梭命令。\n查看穿梭后的日志信息\n明显看到当前指向first version版本。最顶行多出一行日志记录我们进行了版本穿梭。说明版本穿梭也会被Git的日志记录，但版本号不会新增。\n四、Git分支操作 4.1什么是分支 在版本控制过程中，同时推进多个任务，为每廷务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。（分支底层其实也是指针的引用）\n4.2分支的好处 同时并行推进多个功能开发，提高开发效率。\n各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。\n4.3分支的操作 命令名称 作用 git branch 分支名 创建分支 git branch -v 查看分支 git checkout 分支名 切换分支 git merge 分支名 把指定的分支合并到当前分支上 查看分支 git branch -v 创建分支 git branch 分支名 创建一个名为hot-fix的紧急修复分支。\n创建的新分支，会克隆当前分支的的所有状态和信息，比如：历史版本信息等等。\n切换分支 git checkout 分支名 切换成功后会返回切换成功信息，下一个提示符的蓝色括号由原来的master变成了hot-fix。\n同时日志会记录分支切换信息。\n分支修改文件 直接调用vim对最新版本的newfile.md文件进行修改。修改之后的状态与在同一个分支下修改文件相似，这里省略图文介绍，详细参考上文3.8修改文件。之后的步骤是：添加到暂存区、提交到本地库。\n在修改分支提交的版本我们命名为hot-fix first version。\n合并分支 git merge 分支名 合并前先把项目的分支切换到需要合并到的分支上**（master)**\n执行合并命令\n冲突合并 产生冲突的原因：合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改。Git无法替我们决定使用哪一个。必须认为决定新代码的内容。\n模拟冲突合并：\n因为上一步我们刚刚把hot-fix中的 first version合并到mater中来，所以此时mater分支newfile的内容与hot-fix中newfile.md的内容一样。\n我们先把master中的newfile最后一行尾加入master test。再进行添加和提交。版本命名master test。\n再把分支切换到hot-fix，此时内容还未受到master分支的修改而修改。\n这时我们把hot-fix中的newfile的倒数第二行末加上hot-fix test。\n然后添加、提交。版本名为hotfix-version。切换回master分支，执行合并分支。\n此时报错并且当前状态为在master分支上，并且正在合并分支，需要我们人为进入vim选择合并。\n««« HEAD 与======之间的内容表示是当前mater分支的修改内容。 =======与»»»\u003e hot-fix之间的内容表示hot-fix分支的修改内容。\n我们需要手动修改内容并且删除多余的提示符号。\n上图是人工手动修改合并后的信息，保留了两个处在不同分支的操作者对同一文件的修改。\n保存完文件之后，还要把修改完的文件添加到暂存区以及提交到工作区的一系列操作，注意在手动合并后的提交到本地库的命令中不需要带文件名。\n提交完成后，状态变为master。至此我们通过手动合并分支解决了代码冲突。\n注意：合并分支只会修改合并到分支的文件的内容，从哪合并来的哪个分支通过合并操作不会被修改。\n五、Github远程库操作 5.1配置SSH 设置用户签名\n检查是否存在SSH Key\n1ChouS@DESKTOP-78VSLED MINGW64 / 2$ cd ~/.ssh 3 4ChouS@DESKTOP-78VSLED MINGW64 ~/.ssh 5$ ls 6id_rsa id_rsa.pub known_hosts known_hosts.old 存在id_rsa.pub和id_rsa说明存在SSH密钥。\n如果没有，则执行生成SSH Key\n1ChouS@DESKTOP-78VSLED MINGW64 ~/.ssh 2$ ssh -keygen -t rsa -C \"邮箱地址\" 查看SSH Key\n1ChouS@DESKTOP-78VSLED MINGW64 ~/.ssh 2$ cat id_rsa.pub 3ssh-rsa 4以下为密钥内容，此处不做展示。 到Github配置添加密钥\n登陆Github-右上角头像-settings-SSH and GPG keys-add。\n配置好SSH后,在自己的电脑Github会自动与远程库保持通信。\n5.2创建远程仓库 Repository\n公网访问仓库名称为 username.github.io，每个账号只有一个。\n非公网访问仓库名称用户自定义，有很多个供我们使用。\n5.3远程仓库操作 创建远程仓库别名 操作命令 操作名称 git remote -v 查看当前所有远程地址的别名 git remote add 别名 远程地址 设置远程地址的别名 查看远程地址别名有两行，说明这个别名可以用于推送、拉取、克隆等。\n推送本地库代码到远程库 git push 别名/远程链接 分支 推送的最小单位是分支，需要指定推送哪一个分支。\n拉取远程库到本地库 git pull 别名 分支 当本地库与远程库的项目文件内容不一致时，需要先用Pull拉取到本地，更新本地库与远程库保持一致。\n克隆远程仓库到本地 git clone 远程地址 克隆会自动完成：1、拉取代码 2、初始化本地仓库 3、创建别名\n当到一个新环境管理自己的或上级的项目需要克隆到本地以实现初始化和拉取最新代码。\n5.4Github界面介绍 功能名称 作用 Code 展示项目源码，提供源码Clone和打包下载。 Issues 讨论区，可以对项目进行各种提问。我们每个人都可以在本区提出issuse。状态Open：讨论中状态Closed：关闭该帖，已经解决问题。 Pull requests 从Fork的项目发起向原项目合并请求 fork 原项目的拷贝数。 watch 关注项目的变化，如果别人提交了pull、request、发起了issue，在通知中心会收到消息。 star 类似于点赞，表示项目受欢迎度。 branch 分支 tag 标签 5.5Branch与Fork的区别 Fork属于远程托管平台的功能，并不属于Git的branch。\nFork是一个新的仓库，可以随便开分支，只要最后不乱 pull request 乱合并到原项目就不会出事； branch 其实只是一个分支，比一个仓库的范围要小得多，你实际上还是处于同一个项目仓库中。\nPull Request：从Fork过衍生出的新项目向原项目发起合并推送请求。\n5.6顶级域名 申请顶级域名并且指向username.github.io，会使之变为类似www.username.com等高大尚的地址。\n申请渠道 阿里云 腾讯云 GoDaddy freenom 从顶级域名渠道配置指向我们的GitHub地址后，要从GitHub的仓库setting中的Custom domain输入我们购买好的顶级域名，这样顶级域名就配置完成了。\n5.7版本比较 在原项目的网址后面加上\\compare可以访问该项目的版本比较页面，另外也有插件可以使得源码比较起来直观。\n","wordCount":"5765","inLanguage":"en","datePublished":"2022-07-21T15:33:39+08:00","dateModified":"2022-07-21T15:33:39+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://xinb.in/posts/git/"},"publisher":{"@type":"Organization","name":"Xinbin","logo":{"@type":"ImageObject","url":"https://xinb.in/icon.png"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xinb.in/ accesskey=h title="Xinbin (Alt + H)">Xinbin</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://xinb.in/ title=Home><span>Home</span></a></li><li><a href=https://xinb.in/archives title=Blog><span>Blog</span></a></li><li><a href=https://xinb.in/about title=About><span>About</span></a></li></ul></nav></header><script async src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Git</h1><div class=post-meta><span title='2022-07-21 15:33:39 +0800 +0800'>Created on 2022-07-21</span>&nbsp;·&nbsp;12 Min&nbsp;·&nbsp;5765 Words</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#git aria-label=Git>Git</a><ul><li><a href=#%e4%b8%80git%e6%a6%82%e8%bf%b0 aria-label=一、Git概述>一、Git概述</a><ul><li><a href=#11git%e5%8e%86%e5%8f%b2 aria-label=1.1Git历史>1.1Git历史</a></li><li><a href=#12%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6 aria-label=1.2版本控制>1.2版本控制</a></li><li><a href=#13%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6%e5%b7%a5%e5%85%b7 aria-label=1.3版本控制工具>1.3版本控制工具</a><ul><li><a href=#%e9%9b%86%e4%b8%ad%e5%bc%8f%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6%e5%b7%a5%e5%85%b7 aria-label=集中式版本控制工具>集中式版本控制工具</a></li><li><a href=#%e5%88%86%e5%b8%83%e5%bc%8f%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6%e5%b7%a5%e5%85%b7 aria-label=分布式版本控制工具>分布式版本控制工具</a></li></ul></li><li><a href=#14git%e5%b7%a5%e4%bd%9c%e6%9c%ba%e5%88%b6 aria-label=1.4Git工作机制>1.4Git工作机制</a></li><li><a href=#15%e4%bb%a3%e7%a0%81%e6%89%98%e7%ae%a1%e5%b9%b3%e5%8f%b0 aria-label=1.5代码托管平台>1.5代码托管平台</a></li></ul></li><li><a href=#%e4%ba%8cgit%e5%ae%89%e8%a3%85 aria-label=二、Git安装>二、Git安装</a></li><li><a href=#%e4%b8%89git%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4 aria-label=三、Git常用命令>三、Git常用命令</a><ul><li><a href=#31%e7%94%a8%e6%88%b7%e7%ad%be%e5%90%8d aria-label=3.1用户签名>3.1用户签名</a><ul><li><a href=#%e8%ae%be%e7%bd%ae%e7%94%a8%e6%88%b7%e7%ad%be%e5%90%8d aria-label=设置用户签名>设置用户签名</a></li><li><a href=#%e6%9f%a5%e7%9c%8b%e7%94%a8%e6%88%b7%e7%ad%be%e5%90%8d aria-label=查看用户签名>查看用户签名</a></li></ul></li><li><a href=#32%e5%88%9d%e5%a7%8b%e5%8c%96%e6%9c%ac%e5%9c%b0%e5%ba%93 aria-label=3.2初始化本地库>3.2初始化本地库</a></li><li><a href=#33%e6%9f%a5%e7%9c%8b%e6%9c%ac%e5%9c%b0%e5%ba%93%e7%8a%b6%e6%80%81 aria-label=3.3查看本地库状态>3.3查看本地库状态</a></li><li><a href=#34%e6%b7%bb%e5%8a%a0%e5%88%b0%e6%9a%82%e5%ad%98%e5%8c%ba aria-label=3.4添加到暂存区>3.4添加到暂存区</a><ul><li><a href=#%e6%b7%bb%e5%8a%a0%e5%88%b0%e6%9a%82%e5%ad%98%e5%8c%ba aria-label=添加到暂存区>添加到暂存区</a></li><li><a href=#%e6%89%b9%e9%87%8f%e6%b7%bb%e5%8a%a0%e5%88%b0%e6%9a%82%e5%ad%98%e5%8c%ba aria-label=批量添加到暂存区>批量添加到暂存区</a></li><li><a href=#%e4%bb%8e%e6%9a%82%e5%ad%98%e5%8c%ba%e5%88%a0%e9%99%a4 aria-label=从暂存区删除>从暂存区删除</a></li></ul></li><li><a href=#35%e6%8f%90%e4%ba%a4%e5%88%b0%e6%9c%ac%e5%9c%b0%e5%ba%93 aria-label=3.5提交到本地库>3.5提交到本地库</a></li><li><a href=#36%e6%9f%a5%e7%9c%8b%e5%8e%86%e5%8f%b2%e6%97%a5%e5%bf%97 aria-label=3.6查看历史日志>3.6查看历史日志</a></li><li><a href=#37%e6%9f%a5%e7%9c%8b%e8%af%a6%e7%bb%86%e5%8e%86%e5%8f%b2%e6%97%a5%e5%bf%97 aria-label=3.7查看详细历史日志>3.7查看详细历史日志</a></li><li><a href=#38%e4%bf%ae%e6%94%b9%e6%96%87%e4%bb%b6 aria-label=3.8修改文件>3.8修改文件</a><ul><li><a href=#%e4%bf%ae%e6%94%b9%e6%96%87%e4%bb%b6 aria-label=修改文件>修改文件</a></li><li><a href=#%e4%bf%ae%e6%94%b9%e5%90%8e%e7%9a%84%e7%8a%b6%e6%80%81 aria-label=修改后的状态>修改后的状态</a></li><li><a href=#%e6%b7%bb%e5%8a%a0%e5%88%b0%e6%9a%82%e5%ad%98%e5%8c%ba%e5%90%8e%e7%9a%84%e7%8a%b6%e6%80%81 aria-label=添加到暂存区后的状态>添加到暂存区后的状态</a></li><li><a href=#%e6%8f%90%e4%ba%a4%e5%88%b0%e6%9c%ac%e5%9c%b0%e5%ba%93 aria-label=提交到本地库>提交到本地库</a></li><li><a href=#%e6%8f%90%e4%ba%a4%e5%88%b0%e6%9c%ac%e5%9c%b0%e5%ba%93%e5%90%8e%e7%9a%84%e7%8a%b6%e6%80%81 aria-label=提交到本地库后的状态>提交到本地库后的状态</a></li></ul></li><li><a href=#39%e7%89%88%e6%9c%ac%e7%a9%bf%e6%a2%ad aria-label=3.9版本穿梭>3.9版本穿梭</a></li></ul></li><li><a href=#%e5%9b%9bgit%e5%88%86%e6%94%af%e6%93%8d%e4%bd%9c aria-label=四、Git分支操作>四、Git分支操作</a><ul><li><a href=#41%e4%bb%80%e4%b9%88%e6%98%af%e5%88%86%e6%94%af aria-label=4.1什么是分支>4.1什么是分支</a></li><li><a href=#42%e5%88%86%e6%94%af%e7%9a%84%e5%a5%bd%e5%a4%84 aria-label=4.2分支的好处>4.2分支的好处</a></li><li><a href=#43%e5%88%86%e6%94%af%e7%9a%84%e6%93%8d%e4%bd%9c aria-label=4.3分支的操作>4.3分支的操作</a><ul><li><a href=#%e6%9f%a5%e7%9c%8b%e5%88%86%e6%94%af aria-label=查看分支>查看分支</a></li><li><a href=#%e5%88%9b%e5%bb%ba%e5%88%86%e6%94%af aria-label=创建分支>创建分支</a></li><li><a href=#%e5%88%87%e6%8d%a2%e5%88%86%e6%94%af aria-label=切换分支>切换分支</a></li><li><a href=#%e5%88%86%e6%94%af%e4%bf%ae%e6%94%b9%e6%96%87%e4%bb%b6 aria-label=分支修改文件>分支修改文件</a></li><li><a href=#%e5%90%88%e5%b9%b6%e5%88%86%e6%94%af aria-label=合并分支>合并分支</a></li><li><a href=#%e5%86%b2%e7%aa%81%e5%90%88%e5%b9%b6 aria-label=冲突合并>冲突合并</a></li></ul></li></ul></li><li><a href=#%e4%ba%94github%e8%bf%9c%e7%a8%8b%e5%ba%93%e6%93%8d%e4%bd%9c aria-label=五、Github远程库操作>五、Github远程库操作</a><ul><li><a href=#51%e9%85%8d%e7%bd%aessh aria-label=5.1配置SSH>5.1配置SSH</a></li><li><a href=#52%e5%88%9b%e5%bb%ba%e8%bf%9c%e7%a8%8b%e4%bb%93%e5%ba%93 aria-label=5.2创建远程仓库>5.2创建远程仓库</a></li><li><a href=#53%e8%bf%9c%e7%a8%8b%e4%bb%93%e5%ba%93%e6%93%8d%e4%bd%9c aria-label=5.3远程仓库操作>5.3远程仓库操作</a><ul><li><a href=#%e5%88%9b%e5%bb%ba%e8%bf%9c%e7%a8%8b%e4%bb%93%e5%ba%93%e5%88%ab%e5%90%8d aria-label=创建远程仓库别名>创建远程仓库别名</a></li><li><a href=#%e6%8e%a8%e9%80%81%e6%9c%ac%e5%9c%b0%e5%ba%93%e4%bb%a3%e7%a0%81%e5%88%b0%e8%bf%9c%e7%a8%8b%e5%ba%93 aria-label=推送本地库代码到远程库>推送本地库代码到远程库</a></li><li><a href=#%e6%8b%89%e5%8f%96%e8%bf%9c%e7%a8%8b%e5%ba%93%e5%88%b0%e6%9c%ac%e5%9c%b0%e5%ba%93 aria-label=拉取远程库到本地库>拉取远程库到本地库</a></li><li><a href=#%e5%85%8b%e9%9a%86%e8%bf%9c%e7%a8%8b%e4%bb%93%e5%ba%93%e5%88%b0%e6%9c%ac%e5%9c%b0 aria-label=克隆远程仓库到本地>克隆远程仓库到本地</a></li></ul></li><li><a href=#54github%e7%95%8c%e9%9d%a2%e4%bb%8b%e7%bb%8d aria-label=5.4Github界面介绍>5.4Github界面介绍</a></li><li><a href=#55branch%e4%b8%8efork%e7%9a%84%e5%8c%ba%e5%88%ab aria-label=5.5Branch与Fork的区别>5.5Branch与Fork的区别</a></li><li><a href=#56%e9%a1%b6%e7%ba%a7%e5%9f%9f%e5%90%8d aria-label=5.6顶级域名>5.6顶级域名</a><ul><li><a href=#%e7%94%b3%e8%af%b7%e6%b8%a0%e9%81%93 aria-label=申请渠道>申请渠道</a></li></ul></li><li><a href=#57%e7%89%88%e6%9c%ac%e6%af%94%e8%be%83 aria-label=5.7版本比较>5.7版本比较</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=git>Git<a hidden class=anchor aria-hidden=true href=#git>#</a></h1><p>$everything\ is\ local$</p><h2 id=一git概述>一、Git概述<a hidden class=anchor aria-hidden=true href=#一git概述>#</a></h2><p><strong>Git</strong>是一个免费的、开源的<strong>分布式版本控制系统</strong>，可以快速高效的处理从小型到大型的各种项目。</p><p><strong>Git</strong>易于学习， 占用空间小，性能快如闪电。它优于 <strong>SCM</strong> 工具，如 <strong>Subversion</strong>、<strong>CVS</strong>、<strong>Perforce</strong> 和 <strong>ClearCase</strong>，具有廉价的本地分支、方便的暂存区域和多个工作流等功能。</p><h3 id=11git历史>1.1Git历史<a hidden class=anchor aria-hidden=true href=#11git历史>#</a></h3><blockquote><p>Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。</p><p>Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？</p><p>事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！</p><p>你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。</p><p>不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。</p><p>安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。</p><p>Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：</p><p>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。</p><p>Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p><p>历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。</p><p>(摘录于廖雪峰官网Linux教程)</p></blockquote><h3 id=12版本控制>1.2版本控制<a hidden class=anchor aria-hidden=true href=#12版本控制>#</a></h3><p>团队开发需要记录项目版本以及正确的版本控制，<strong>Git</strong>版本控制软件由此而来。</p><h3 id=13版本控制工具>1.3版本控制工具<a hidden class=anchor aria-hidden=true href=#13版本控制工具>#</a></h3><h4 id=集中式版本控制工具>集中式版本控制工具<a hidden class=anchor aria-hidden=true href=#集中式版本控制工具>#</a></h4><p><strong>CVS</strong>、<strong>SVN（subversion）</strong>、<strong>VSS</strong>&mldr;&mldr;</p><p>集中化的版本控制系统诸如<strong>CVS</strong>、<strong>SVN</strong>等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。</p><p>优点是每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统，要远比在各个客户端上维护本地数据库来得轻松容易。</p><p>缺点是中央服务器的单点故障。如果服务器宕机一小时，那么在这一小时内，准都无法提交更新，也就无法协同工作。</p><h4 id=分布式版本控制工具>分布式版本控制工具<a hidden class=anchor aria-hidden=true href=#分布式版本控制工具>#</a></h4><p><strong>Git</strong>、<strong>Mercurial</strong>、<strong>Bazaar</strong>、<strong>Darcs</strong>&mldr;&mldr;</p><p>像<strong>Git</strong>这种分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来（本地库）。这样任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份。</p><p>分布式的版本控制系统出现之后，解决了集中式版本控制系统的缺陷：</p><ol><li>服务器断网的情况下也可以进行开发（因为<strong>版本控制是在本地进行的</strong>）</li><li>每个客户端保存的也都是整个完整的项目（包含历史记录，更加安全）</li></ol><h3 id=14git工作机制>1.4Git工作机制<a hidden class=anchor aria-hidden=true href=#14git工作机制>#</a></h3><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/chousinbin/Image/git%e5%b7%a5%e4%bd%9c%e6%9c%ba%e5%88%b6.png alt></p><p>只有把代码提交到本地库，才会产生历史版本。</p><p>本地库→<strong>git push</strong>→远程库</p><h3 id=15代码托管平台>1.5代码托管平台<a hidden class=anchor aria-hidden=true href=#15代码托管平台>#</a></h3><p>代码托管中心是基于网络服务器的远程代码仓库，一般称为<strong>远程库</strong>。</p><p>局域网：<strong>Gitlab</strong></p><p>互联网：<strong>Github</strong>、<strong>Gitee</strong>码云</p><h2 id=二git安装>二、Git安装<a hidden class=anchor aria-hidden=true href=#二git安装>#</a></h2><p>Git官网：https://git-scm.com/</p><p>默认选项安装</p><p>查看Git版本</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=ln>1</span><span class=cl>ChouS@DESKTOP-78VSLED MINGW64 ~
</span></span><span class=line><span class=ln>2</span><span class=cl>$ git --version
</span></span><span class=line><span class=ln>3</span><span class=cl>git version 2.37.0.windows.1
</span></span></code></pre></div><h2 id=三git常用命令>三、Git常用命令<a hidden class=anchor aria-hidden=true href=#三git常用命令>#</a></h2><p>大部分命令与Linux通用。</p><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git config &ndash;global user.name 用户名</td><td>设置用户签名</td></tr><tr><td>git config &ndash;global user.email 邮箱</td><td>设置用户签名</td></tr><tr><td>git init</td><td>初始化本地库</td></tr><tr><td>git status</td><td>查看本地库状态</td></tr><tr><td>git add 文件名</td><td>添加到暂存区</td></tr><tr><td>git rm &ndash;cached 文件名</td><td>从暂存区删除</td></tr><tr><td>git commit -m &ldquo;版本信息&rdquo; 文件名</td><td>提交到本地库</td></tr><tr><td>git reflog</td><td>查看历史纪录</td></tr><tr><td>git reset &ndash;hard 版本号</td><td>版本穿梭</td></tr><tr><td>git log</td><td>查看当前版本详细日志</td></tr></tbody></table><h3 id=31用户签名>3.1用户签名<a hidden class=anchor aria-hidden=true href=#31用户签名>#</a></h3><h4 id=设置用户签名>设置用户签名<a hidden class=anchor aria-hidden=true href=#设置用户签名>#</a></h4><pre tabindex=0><code>git config --global user.name 用户签名
git config --global user.email 用户邮箱
</code></pre><h4 id=查看用户签名>查看用户签名<a hidden class=anchor aria-hidden=true href=#查看用户签名>#</a></h4><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/chousinbin/Image/%e6%9f%a5%e7%9c%8b%e7%94%a8%e6%88%b7%e7%ad%be%e5%90%8d.png alt></p><p>注意：</p><ol><li>签名的作用是区分不同操作者的身份。用户签名信息在每一个版本的提交信息中能够看到，以此确定本次提交的谁做的。</li><li>Git首次安装必须设置一下用户签名，否则无法提交代码。</li><li>这里设置的用户签名的用户名和邮箱与将来登录代码托管平台的账号没有任何关系。</li></ol><h3 id=32初始化本地库>3.2初始化本地库<a hidden class=anchor aria-hidden=true href=#32初始化本地库>#</a></h3><pre tabindex=0><code>git init
</code></pre><p>在项目根文件夹中<code>右键</code>选择<code>git bush</code> ，输入上命令，完成初始化本地库。</p><h3 id=33查看本地库状态>3.3查看本地库状态<a hidden class=anchor aria-hidden=true href=#33查看本地库状态>#</a></h3><pre tabindex=0><code>git status
</code></pre><p>红名文件说明是改动的文件，未被添加到暂存区。</p><p>绿名文件，说明该文件状态已经从工作区<code>add</code>到暂存区，说明Git追踪到了该文件。</p><h3 id=34添加到暂存区>3.4添加到暂存区<a hidden class=anchor aria-hidden=true href=#34添加到暂存区>#</a></h3><h4 id=添加到暂存区>添加到暂存区<a hidden class=anchor aria-hidden=true href=#添加到暂存区>#</a></h4><pre tabindex=0><code>git add 文件名
</code></pre><h4 id=批量添加到暂存区>批量添加到暂存区<a hidden class=anchor aria-hidden=true href=#批量添加到暂存区>#</a></h4><ol><li><p>添加多个文件，文件之间以空格隔开</p><pre tabindex=0><code>git add file1 file2 file3
</code></pre></li><li><p>添加指定文件夹下的文件或者指定文件夹下指定格式文件</p><pre tabindex=0><code>git add 算法/*  //把算法文件夹下的全部文件添加到暂存区
git add 算法/*.md  //把算法文件夹下.md格式的文件添加到暂存区
</code></pre></li><li><p>添加所有文件</p><pre tabindex=0><code>git add .
git add --all
</code></pre></li></ol><h4 id=从暂存区删除>从暂存区删除<a hidden class=anchor aria-hidden=true href=#从暂存区删除>#</a></h4><p>添加到暂存区还不会被版本控制记录，可以进行从暂存区删除命令。</p><pre tabindex=0><code>git rm --cached 文件名
</code></pre><p>这个删除只是从暂存区删除，不会删除工作区的源文件。</p><h3 id=35提交到本地库>3.5提交到本地库<a hidden class=anchor aria-hidden=true href=#35提交到本地库>#</a></h3><pre tabindex=0><code>git commit -m &#34;版本信息&#34; 文件名
</code></pre><p>执行该命令后，把暂存区的文件提交到本地库。此时，文件被版本控制记录。</p><h3 id=36查看历史日志>3.6查看历史日志<a hidden class=anchor aria-hidden=true href=#36查看历史日志>#</a></h3><pre tabindex=0><code>git reflog
</code></pre><p>显示当前项目的所有历史版本，以及对应版本的版本号前七位（如本数据<code>c16588d</code>）。</p><h3 id=37查看详细历史日志>3.7查看详细历史日志<a hidden class=anchor aria-hidden=true href=#37查看详细历史日志>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=ln>1</span><span class=cl>ChouS@DESKTOP-78VSLED MINGW64 /e/Github/Notes <span class=o>(</span>master<span class=o>)</span>
</span></span><span class=line><span class=ln>2</span><span class=cl>$ git log
</span></span><span class=line><span class=ln>3</span><span class=cl>commit b2325b3a938da90867449087ef4abfaaf2b96637 <span class=o>(</span>HEAD -&gt; master, notes/master<span class=o>)</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>Author: SinbinChou &lt;chousinbin@163.com&gt;
</span></span><span class=line><span class=ln>5</span><span class=cl>Date:   Wed Jul <span class=m>20</span> 21:57:31 <span class=m>2022</span> +0800
</span></span><span class=line><span class=ln>6</span><span class=cl>
</span></span><span class=line><span class=ln>7</span><span class=cl>    2022-07-20
</span></span></code></pre></div><p>显示当前项目当前版本的详细日志信息。比如：完整的版本号、提交者的签名、提交时间、版本名等。</p><h3 id=38修改文件>3.8修改文件<a hidden class=anchor aria-hidden=true href=#38修改文件>#</a></h3><h4 id=修改文件>修改文件<a hidden class=anchor aria-hidden=true href=#修改文件>#</a></h4><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/chousinbin/Image/%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6.png alt=image-20220711220754217-165754847572118></p><p>修改<code>newfile</code>文件第一行尾添加了<code>222</code>。</p><h4 id=修改后的状态>修改后的状态<a hidden class=anchor aria-hidden=true href=#修改后的状态>#</a></h4><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/chousinbin/Image/%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E7%8A%B6%E6%80%81.png alt=image-20220711220916755-165754855792719></p><p>再次查看状态，我们发现有提示<code>modified:文件名</code>，这种状态说明此文件被修改过了。</p><p>另外这个提示是红色字体，所以这个修改的文件还没有被添加到暂存区，需要对此文件进行添加到暂存区。</p><h4 id=添加到暂存区后的状态>添加到暂存区后的状态<a hidden class=anchor aria-hidden=true href=#添加到暂存区后的状态>#</a></h4><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/chousinbin/Image/%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E6%9A%82%E5%AD%98%E5%8C%BA%E5%90%8E%E7%9A%84%E7%8A%B6%E6%80%81.png alt=image-20220711221322293-165754880347220></p><p>添加到暂存区后，再次查看状态，绿色状态表明：当前文件是被修改且添加到暂存区后未被提交到本地库的文件。</p><h4 id=提交到本地库>提交到本地库<a hidden class=anchor aria-hidden=true href=#提交到本地库>#</a></h4><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/chousinbin/Image/%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%8F%90%E4%BA%A4%E5%88%B0%E6%9C%AC%E5%9C%B0%E5%90%8E%E7%9A%84%E7%8A%B6%E6%80%81.png alt=image-20220711221637309-165754899852521></p><p>提交到本地库后返回操作者提交的版本信息、文件修改的数量、行数的插入数与删除数。</p><p>我们明明是在一行的结尾添加了数字$2$，为什么返回的信息是一行插入和一行删除呢？</p><p>因为Git是按照行来编辑的，在修改文件信息时，先删除当前行，再把修改后的信息插入到原来的位置。</p><h4 id=提交到本地库后的状态>提交到本地库后的状态<a hidden class=anchor aria-hidden=true href=#提交到本地库后的状态>#</a></h4><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/chousinbin/Image/%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%8F%90%E4%BA%A4%E5%88%B0%E6%9C%AC%E5%9C%B0%E5%BA%93%E5%90%8E%E7%9A%84%E7%8A%B6%E6%80%81.png alt=image-20220711222302344-165754938352122></p><p>世界恢复了原有的平静。</p><p>虽然我们对此项目的一个文件可能进行多个版本的修改，但是本地源文件只有一个，版本控制由Git掌管。</p><h3 id=39版本穿梭>3.9版本穿梭<a hidden class=anchor aria-hidden=true href=#39版本穿梭>#</a></h3><pre tabindex=0><code>git reset --hard 版本号
</code></pre><p>先找到版本号（前7位就可以）</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/chousinbin/Image/%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E4%BF%A1%E6%81%AF%E6%9F%A5%E6%89%BE%E7%89%88%E6%9C%AC%E5%8F%B7.png alt=image-20220711223246142-165754996722826></p><p>选中要穿梭到的版本号，右击复制，执行版本穿梭命令。</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/chousinbin/Image/%E6%89%A7%E8%A1%8C%E7%A9%BF%E6%A2%AD%E5%91%BD%E4%BB%A4.png alt=image-20220711223518949-165755011993527></p><p>查看穿梭后的日志信息</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/chousinbin/Image/%E7%A9%BF%E6%A2%AD%E5%90%8E%E7%9A%84%E6%97%A5%E5%BF%97%E4%BF%A1%E6%81%AF.png alt=image-20220711223609404-165755017064528></p><p>明显看到当前指向<code>first version</code>版本。最顶行多出一行日志记录我们进行了版本穿梭。说明<strong>版本穿梭也会被Git的日志记录，但版本号不会新增。</strong></p><h2 id=四git分支操作>四、Git分支操作<a hidden class=anchor aria-hidden=true href=#四git分支操作>#</a></h2><h3 id=41什么是分支>4.1什么是分支<a hidden class=anchor aria-hidden=true href=#41什么是分支>#</a></h3><p>在版本控制过程中，同时推进多个任务，为每廷务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。（分支底层其实也是指针的引用）</p><h3 id=42分支的好处>4.2分支的好处<a hidden class=anchor aria-hidden=true href=#42分支的好处>#</a></h3><p>同时并行推进多个功能开发，提高开发效率。</p><p>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。</p><h3 id=43分支的操作>4.3分支的操作<a hidden class=anchor aria-hidden=true href=#43分支的操作>#</a></h3><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git branch 分支名</td><td>创建分支</td></tr><tr><td>git branch -v</td><td>查看分支</td></tr><tr><td>git checkout 分支名</td><td>切换分支</td></tr><tr><td>git merge 分支名</td><td>把指定的分支合并到当前分支上</td></tr></tbody></table><h4 id=查看分支>查看分支<a hidden class=anchor aria-hidden=true href=#查看分支>#</a></h4><pre tabindex=0><code>git branch -v
</code></pre><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/chousinbin/Image/%E6%9F%A5%E7%9C%8B%E5%88%86%E6%94%AF.png alt=image-20220711231102512-165755226339829></p><h4 id=创建分支>创建分支<a hidden class=anchor aria-hidden=true href=#创建分支>#</a></h4><pre tabindex=0><code>git branch 分支名
</code></pre><p>创建一个名为<code>hot-fix</code>的紧急修复分支。</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/chousinbin/Image/%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF.png alt=image-20220711231323977-165755240493430></p><p>创建的新分支，会克隆当前分支的的所有状态和信息，比如：历史版本信息等等。</p><h4 id=切换分支>切换分支<a hidden class=anchor aria-hidden=true href=#切换分支>#</a></h4><pre tabindex=0><code>git checkout 分支名
</code></pre><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/chousinbin/Image/%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF.png alt=image-20220711231543838-165755254481331></p><p>切换成功后会返回切换成功信息，下一个提示符的蓝色括号由原来的<code>master</code>变成了<code>hot-fix</code>。</p><p>同时日志会记录分支切换信息。</p><h4 id=分支修改文件>分支修改文件<a hidden class=anchor aria-hidden=true href=#分支修改文件>#</a></h4><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/chousinbin/Image/%E5%88%86%E6%94%AF%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6.png alt=image-20220711233153248-165755351431233></p><p>直接调用<code>vim</code>对最新版本的<code>newfile.md</code>文件进行修改。修改之后的状态与在同一个分支下修改文件相似，这里省略图文介绍，详细参考上文<code>3.8修改文件</code>。之后的步骤是：添加到暂存区、提交到本地库。</p><p>在修改分支提交的版本我们命名为<code>hot-fix first version</code>。</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/chousinbin/Image/%E5%88%86%E6%94%AF%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%8F%90%E4%BA%A4.png alt=image-20220711232825334-165755330625032></p><h4 id=合并分支>合并分支<a hidden class=anchor aria-hidden=true href=#合并分支>#</a></h4><pre tabindex=0><code>git merge 分支名 
</code></pre><p>合并前先把项目的分支切换到需要合并到的分支上**（master)**</p><p>执行合并命令</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/chousinbin/Image/%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF.png alt=image-20220711233445810-165755368669935></p><h4 id=冲突合并>冲突合并<a hidden class=anchor aria-hidden=true href=#冲突合并>#</a></h4><p>产生冲突的原因：合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改。Git无法替我们决定使用哪一个。必须认为决定新代码的内容。</p><p>模拟冲突合并：</p><p>因为上一步我们刚刚把<code>hot-fix</code>中的<code> first version</code>合并到<code>mater</code>中来，所以此时<code>mater</code>分支<code>newfile</code>的内容与<code>hot-fix</code>中<code>newfile.md</code>的内容一样。</p><p>我们先把<code>master</code>中的<code>newfile</code>最后一行尾加入<code>master test</code>。再进行添加和提交。版本命名<code>master test</code>。</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/chousinbin/Image/%E5%86%B2%E7%AA%81%E5%90%88%E5%B9%B61.png alt=image-20220711234546010-165755434724336></p><p>再把分支切换到<code>hot-fix</code>，此时内容还未受到<code>master</code>分支的修改而修改。</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/chousinbin/Image/%E5%86%B2%E7%AA%81%E5%90%88%E5%B9%B62.png alt=image-20220711235010268-165755461144537></p><p>这时我们把<code>hot-fix</code>中的<code>newfile</code>的倒数第二行末加上<code>hot-fix test</code>。</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/chousinbin/Image/%E5%86%B2%E7%AA%81%E5%90%88%E5%B9%B63.png alt=image-20220711235533164-165755493419538></p><p>然后添加、提交。版本名为<code>hotfix-version</code>。切换回<code>master</code>分支，执行合并分支。</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/chousinbin/Image/%E5%86%B2%E7%AA%81%E5%90%88%E5%B9%B65.png alt=image-20220712000055116-165755525709140></p><p>此时报错并且当前状态为在<code>master</code>分支上，并且正在合并分支，需要我们人为进入<strong>vim</strong>选择合并。</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/chousinbin/Image/%E5%86%B2%E7%AA%81%E5%90%88%E5%B9%B66.png alt=image-20220712000249139-165755537016641></p><p>&#171;&#171;&#171; HEAD 与<code>======</code>之间的内容表示是当前<strong>mater</strong>分支的修改内容。
<code>=======</code>与&#187;&#187;&#187;> <strong>hot-fix</strong>之间的内容表示<strong>hot-fix</strong>分支的修改内容。</p><p>我们需要手动修改内容并且删除多余的提示符号。</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/chousinbin/Image/%E5%86%B2%E7%AA%81%E5%90%88%E5%B9%B67.png alt=image-20220712000625610-165755558659742></p><p>上图是人工手动修改合并后的信息，保留了两个处在不同分支的操作者对同一文件的修改。</p><p>保存完文件之后，还要把修改完的文件添加到暂存区以及提交到工作区的一系列操作，注意在<strong>手动合并后的提交到本地库的命令中不需要带文件名</strong>。</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/chousinbin/Image/%E5%86%B2%E7%AA%81%E5%90%88%E5%B9%B68.png alt=image-20220712001330058-165755601223843></p><p>提交完成后，状态变为<code>master</code>。至此我们通过手动合并分支解决了代码冲突。</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/chousinbin/Image/%E5%86%B2%E7%AA%81%E5%90%88%E5%B9%B69.png alt=image-20220712001740176-165755626155745></p><p>注意：合并分支只会修改合并到分支的文件的内容，从哪合并来的哪个分支通过合并操作不会被修改。</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/chousinbin/Image/%E5%86%B2%E7%AA%81%E5%90%88%E5%B9%B610.png alt=image-20220712001648472-165755620941644></p><h2 id=五github远程库操作>五、Github远程库操作<a hidden class=anchor aria-hidden=true href=#五github远程库操作>#</a></h2><h3 id=51配置ssh>5.1配置SSH<a hidden class=anchor aria-hidden=true href=#51配置ssh>#</a></h3><ol><li><p>设置用户签名</p></li><li><p>检查是否存在<strong>SSH Key</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=ln>1</span><span class=cl>ChouS@DESKTOP-78VSLED MINGW64 /
</span></span><span class=line><span class=ln>2</span><span class=cl>$ <span class=nb>cd</span> ~/.ssh
</span></span><span class=line><span class=ln>3</span><span class=cl>
</span></span><span class=line><span class=ln>4</span><span class=cl>ChouS@DESKTOP-78VSLED MINGW64 ~/.ssh
</span></span><span class=line><span class=ln>5</span><span class=cl>$ ls
</span></span><span class=line><span class=ln>6</span><span class=cl>id_rsa  id_rsa.pub  known_hosts  known_hosts.old
</span></span></code></pre></div><p>存在<code>id_rsa.pub</code>和<code>id_rsa</code>说明存在<strong>SSH</strong>密钥。</p></li><li><p>如果没有，则执行生成<strong>SSH Key</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=ln>1</span><span class=cl>ChouS@DESKTOP-78VSLED MINGW64 ~/.ssh
</span></span><span class=line><span class=ln>2</span><span class=cl>$ ssh -keygen -t rsa -C <span class=s2>&#34;邮箱地址&#34;</span>
</span></span></code></pre></div></li><li><p>查看<strong>SSH Key</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=ln>1</span><span class=cl>ChouS@DESKTOP-78VSLED MINGW64 ~/.ssh
</span></span><span class=line><span class=ln>2</span><span class=cl>$ cat id_rsa.pub
</span></span><span class=line><span class=ln>3</span><span class=cl>ssh-rsa 
</span></span><span class=line><span class=ln>4</span><span class=cl>以下为密钥内容，此处不做展示。
</span></span></code></pre></div></li><li><p>到<strong>Github</strong>配置添加密钥</p><p>登陆Github-右上角头像-<strong>settings</strong>-<strong>SSH and GPG keys</strong>-<strong>add</strong>。</p></li></ol><p><strong>配置好SSH后,在自己的电脑Github会自动与远程库保持通信。</strong></p><h3 id=52创建远程仓库>5.2创建远程仓库<a hidden class=anchor aria-hidden=true href=#52创建远程仓库>#</a></h3><p><strong>Repository</strong></p><p>公网访问仓库名称为 <code>username.github.io</code>，每个账号只有一个。</p><p>非公网访问仓库名称用户自定义，有很多个供我们使用。</p><h3 id=53远程仓库操作>5.3远程仓库操作<a hidden class=anchor aria-hidden=true href=#53远程仓库操作>#</a></h3><h4 id=创建远程仓库别名>创建远程仓库别名<a hidden class=anchor aria-hidden=true href=#创建远程仓库别名>#</a></h4><table><thead><tr><th>操作命令</th><th>操作名称</th></tr></thead><tbody><tr><td>git remote -v</td><td>查看当前所有远程地址的别名</td></tr><tr><td>git remote add 别名 远程地址</td><td>设置远程地址的别名</td></tr></tbody></table><p>查看远程地址别名有两行，说明这个别名可以用于推送、拉取、克隆等。</p><h4 id=推送本地库代码到远程库>推送本地库代码到远程库<a hidden class=anchor aria-hidden=true href=#推送本地库代码到远程库>#</a></h4><pre tabindex=0><code>git push 别名/远程链接 分支
</code></pre><p>推送的最小单位是分支，需要指定推送哪一个分支。</p><h4 id=拉取远程库到本地库>拉取远程库到本地库<a hidden class=anchor aria-hidden=true href=#拉取远程库到本地库>#</a></h4><pre tabindex=0><code>git pull 别名 分支
</code></pre><p>当本地库与远程库的项目文件内容不一致时，需要先用<code>Pull</code>拉取到本地，更新本地库与远程库保持一致。</p><h4 id=克隆远程仓库到本地>克隆远程仓库到本地<a hidden class=anchor aria-hidden=true href=#克隆远程仓库到本地>#</a></h4><pre tabindex=0><code>git clone 远程地址
</code></pre><p>克隆会自动完成：1、拉取代码 2、初始化本地仓库 3、创建别名</p><p>当到一个新环境管理自己的或上级的项目需要克隆到本地以实现初始化和拉取最新代码。</p><h3 id=54github界面介绍>5.4Github界面介绍<a hidden class=anchor aria-hidden=true href=#54github界面介绍>#</a></h3><table><thead><tr><th>功能名称</th><th>作用</th></tr></thead><tbody><tr><td><code>Code</code></td><td>展示项目源码，提供源码<code>Clone</code>和打包下载。</td></tr><tr><td><code>Issues</code></td><td>讨论区，可以对项目进行各种提问。我们每个人都可以在本区提出<code>issuse</code>。状态<code>Open</code>：讨论中状态<code>Closed</code>：关闭该帖，已经解决问题。</td></tr><tr><td><code>Pull requests</code></td><td>从Fork的项目发起向原项目合并请求</td></tr><tr><td><code>fork</code></td><td>原项目的拷贝数。</td></tr><tr><td><code>watch</code></td><td>关注项目的变化，如果别人提交了<code>pull</code>、<code>request</code>、发起了<code>issue</code>，在通知中心会收到消息。</td></tr><tr><td><code>star</code></td><td>类似于点赞，表示项目受欢迎度。</td></tr><tr><td><code>branch</code></td><td>分支</td></tr><tr><td><code>tag</code></td><td>标签</td></tr></tbody></table><h3 id=55branch与fork的区别>5.5Branch与Fork的区别<a hidden class=anchor aria-hidden=true href=#55branch与fork的区别>#</a></h3><p><code>Fork</code>属于远程托管平台的功能，并不属于<code>Git</code>的<code>branch</code>。</p><p><code>Fork</code>是一个新的仓库，可以随便开分支，只要最后不乱 <code>pull request</code> 乱合并到原项目就不会出事；
<code>branch</code> 其实只是一个分支，比一个仓库的范围要小得多，你实际上还是处于同一个项目仓库中。</p><p><code>Pull Request</code>：从<code>Fork</code>过衍生出的新项目向原项目发起合并推送请求。</p><h3 id=56顶级域名>5.6顶级域名<a hidden class=anchor aria-hidden=true href=#56顶级域名>#</a></h3><p>申请顶级域名并且指向<code>username.github.io</code>，会使之变为类似<code>www.username.com</code>等高大尚的地址。</p><h4 id=申请渠道>申请渠道<a hidden class=anchor aria-hidden=true href=#申请渠道>#</a></h4><ol><li>阿里云</li><li>腾讯云</li><li>GoDaddy</li><li>freenom</li></ol><p>从顶级域名渠道配置指向我们的GitHub地址后，要从<strong>GitHub</strong>的仓库<code>setting</code>中的<code>Custom domain</code>输入我们购买好的顶级域名，这样顶级域名就配置完成了。</p><h3 id=57版本比较>5.7版本比较<a hidden class=anchor aria-hidden=true href=#57版本比较>#</a></h3><p>在原项目的网址后面加上<code>\compare</code>可以访问该项目的版本比较页面，另外也有插件可以使得源码比较起来直观。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://xinb.in/tags/git/>Git</a></li><li><a href=https://xinb.in/tags/github/>GitHub</a></li></ul><nav class=paginav><a class=prev href=https://xinb.in/posts/240128/><span class=title>« Prev</span><br><span>[转载] 获取 GS3101 管理员密码</span>
</a><a class=next href=https://xinb.in/posts/220608/><span class=title>Next »</span><br><span>深夜的一声汽笛</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=chousinbin/chousinbin.github.io data-repo-id=R_kgDOHnr35Q data-category=Announcements data-category-id=DIC_kwDOHnr35c4Cga43 data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=en crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://xinb.in/>Xinbin</a></span> ·
<script defer src=https://cn.vercount.one/js></script>Views: <span id=busuanzi_value_site_pv></span> · Visitors: <span id=busuanzi_value_site_uv></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function s(){t.innerHTML="Copied!",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>