---
title: PAT乙级-1025-反转链表
tags: PAT乙级
---

被虐的一题，做了40min没做出来。

## 题目描述

给定一个常数 *K* 以及一个单链表 *L*，请编写程序将 *L* 中每 *K* 个结点反转。例如：给定 *L* 为 1→2→3→4→5→6，*K* 为 3，则输出应该为 3→2→1→6→5→4；如果 *K* 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 *K* 个元素不反转。

### 输入格式

每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 *N* (≤105)、以及正整数 *K* (≤*N*)，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。

接下来有 *N* 行，每行格式为：

```
Address Data Next
```

其中 `Address` 是结点地址，`Data` 是该结点保存的整数数据，`Next` 是下一结点的地址。

### 输出格式

对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。

### 输入样例

```in
00100 6 4
00000 4 99999
00100 1 12309
68237 6 -1
33218 3 00000
99999 5 68237
12309 2 33218
```

### 输出样例

```out
00000 4 33218
33218 3 12309
12309 2 00100
00100 1 99999
99999 5 68237
68237 6 -1
```

## 解题思路

存储每个地址的值和当前地址的下一个地址，再按照原地址顺序遍历链表并且按照原顺序存储地址。

利用**STL**函数**reverse**，按照**K**的长度翻转地址。

根据**翻转后的地址**和**存储翻转后地址数组的下标**，顺序输出当前结点的地址－值－下一个地址。

## AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=1e5+10;

int h,k,n;
int ne[N];
int e[N];
int l[N];  //存储地址


int main()
{
    cin>>h>>n>>k;
    for(int i=0;i<n;i++)
    {
        int a,b,c;
        cin>>a>>b>>c;
        e[a]=b,ne[a]=c;
    }
    
    int cnt=0;  //计数
    for(int i=h;i!=-1;i=ne[i])  //按原顺序遍历链表存储地址
        l[cnt++]=i;
    
    for(int i=0;i+k<=cnt;i+=k)  //根据k翻转区域的原地址
        reverse(l+i,l+i+k);
    
    for(int i=0;i<cnt;i++)  //输出
        if(i+1==cnt) printf("%05d %d -1\n",l[i],e[l[i]]);  //最后一个结点
        else printf("%05d %d %05d\n",l[i],e[l[i]],l[i+1]);  //l[i+1]根据下表确定下一个地址
    
    return 0;
}
```



